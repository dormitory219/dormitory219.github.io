<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>一个优雅的hybrid方案：native,JS端两端实现 | hello,Joy</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="CSWebViewJavascriptBridgehttps://github.com/dormitory219/CSWebViewJavascriptBridge.git CSWebViewJavascriptBridge是一套hybrid方案，包括iOS端与Web端的实现，可以为任意webView提供hybrid能力，也可以直接使用webBrowViewController提供的hybrid能">
<meta property="og:type" content="article">
<meta property="og:title" content="一个优雅的hybrid方案：native,JS端两端实现">
<meta property="og:url" content="https://github.com/dormitory219/2018/07/29/一个优雅的hybrid方案：native,JS端两端实现/index.html">
<meta property="og:site_name" content="hello,Joy">
<meta property="og:description" content="CSWebViewJavascriptBridgehttps://github.com/dormitory219/CSWebViewJavascriptBridge.git CSWebViewJavascriptBridge是一套hybrid方案，包括iOS端与Web端的实现，可以为任意webView提供hybrid能力，也可以直接使用webBrowViewController提供的hybrid能">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://github.com/dormitory219/CSWebViewJavascriptBridge/blob/master/Readme/CSJSBridge.png">
<meta property="og:image" content="https://github.com/dormitory219/CSWebViewJavascriptBridge/blob/master/Readme/CSJSHandlers.png">
<meta property="og:image" content="https://github.com/dormitory219/CSWebViewJavascriptBridge/blob/master/Readme/web.png">
<meta property="og:updated_time" content="2018-09-07T13:45:53.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一个优雅的hybrid方案：native,JS端两端实现">
<meta name="twitter:description" content="CSWebViewJavascriptBridgehttps://github.com/dormitory219/CSWebViewJavascriptBridge.git CSWebViewJavascriptBridge是一套hybrid方案，包括iOS端与Web端的实现，可以为任意webView提供hybrid能力，也可以直接使用webBrowViewController提供的hybrid能">
<meta name="twitter:image" content="https://github.com/dormitory219/CSWebViewJavascriptBridge/blob/master/Readme/CSJSBridge.png">
  
    <link rel="alternate" href="/atom.xml" title="hello,Joy" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">hello,Joy</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Walk steps step by step</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/dormitory219"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-一个优雅的hybrid方案：native,JS端两端实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/29/一个优雅的hybrid方案：native,JS端两端实现/" class="article-date">
  <time datetime="2018-07-29T12:54:00.000Z" itemprop="datePublished">2018-07-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      一个优雅的hybrid方案：native,JS端两端实现
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="CSWebViewJavascriptBridge"><a href="#CSWebViewJavascriptBridge" class="headerlink" title="CSWebViewJavascriptBridge"></a>CSWebViewJavascriptBridge</h1><p><a href="https://github.com/dormitory219/CSWebViewJavascriptBridge.git">https://github.com/dormitory219/CSWebViewJavascriptBridge.git</a></p>
<p><strong>CSWebViewJavascriptBridge是一套hybrid方案，包括iOS端与Web端的实现，可以为任意webView提供hybrid能力，也可以直接使用webBrowViewController提供的hybrid能力。JS端的依赖脚本提前注入到native的webview中，业务JS中可直接根据业务模块进行调用，扩充。</strong></p>
<p>整体框架如图：</p>
<p>1.Bridge:</p>
<p><img src="https://github.com/dormitory219/CSWebViewJavascriptBridge/blob/master/Readme/CSJSBridge.png" alt="Alt text"></p>
<p>2.Handler,Action:</p>
<p><img src="https://github.com/dormitory219/CSWebViewJavascriptBridge/blob/master/Readme/CSJSHandlers.png" alt="Alt text"></p>
<p>3.JS</p>
<p><img src="https://github.com/dormitory219/CSWebViewJavascriptBridge/blob/master/Readme/web.png" alt="Alt text"></p>
<h3 id="说点其他的，hybrid能力分两大类"><a href="#说点其他的，hybrid能力分两大类" class="headerlink" title="说点其他的，hybrid能力分两大类"></a>说点其他的，hybrid能力分两大类</h3><ol>
<li>web主动调用native,native处理完业务逻辑后回调web，web再处理相关业务逻辑;</li>
<li>native主动调用web,web处理完业务逻辑后回调native;</li>
</ol>
<p>在iOS端可通过UIWebView ,WKWebView进行web业务的展示，基于两种webview的native交互方法不同，本套方案中的JS-native交互使用的不是假跳转，如果native端使用UIWebView，则通过javascriptcore框架来进行hybrid交互，如果native端使用WKWebView，则通过window.webkit.messageHandlers方式来进行交互。</p>
<p>在本方案中，native-JS交互核心功能由CSWebViewJavascriptBridge提供，配合不同的webview提供子类化的业务定制，<br>比如：CSUIWebViewJavascriptBridge提供UIWebview的hybrid交互，CSWKWebViewJavascriptBridge提供WKWebview的hybrid的交互。</p>
<p>下面来分别讲述本方案中native调用JS，JS调用native的流程及技术实现：</p>
<h2 id="本方案技术实现"><a href="#本方案技术实现" class="headerlink" title="本方案技术实现:"></a>本方案技术实现:</h2><h3 id="核心通信实现"><a href="#核心通信实现" class="headerlink" title="核心通信实现:"></a>核心通信实现:</h3><h4 id="1-JS调用native"><a href="#1-JS调用native" class="headerlink" title="1. JS调用native:"></a>1. JS调用native:</h4><p>   JS中webCallNative方法进行JS对native的业务调用，该方法挂载在CSJSBridgeCore上，调用时传入一个callback作为回调，每次调用时生成一个callbackID与callback映射到一个map中去。然后真正调用根据native端平台的判定，调不同方法。</p>
<p>   对于iOS，由于UIWebView,WKWebView的交互通信方法不同，提供不同的交互方案，对于UIWebView，最终调用的是CSJSWebViewBridgeCore.callApp(msg)，而WKWebView调用的是window.webkit.messageHandlers.CSJSWebViewBridgeCore.postMessage(msg)</p>
<p>   以下是CSJSBridgeCore.js部分实现：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CSJSBridgeCore.prototype.webCallNative = function(data,callback)&#123;</span><br><span class="line">var msgBody = &#123;&#125;;</span><br><span class="line">msgBody.handler = data.handler;</span><br><span class="line">msgBody.action = data.action;</span><br><span class="line">msgBody.data = data.data;</span><br><span class="line">if(callback)&#123;</span><br><span class="line">    msgBody.callbackID = _getCallbackID();</span><br><span class="line">&#125;</span><br><span class="line">msgBody.callbackFunction = &quot;jsBridge.callbackWeb&quot;;</span><br><span class="line">msgBody.nativeCallWebFunction = &quot;jsBridge.nativeCallWeb&quot;;</span><br><span class="line">if (callback &amp;&amp; typeof(callback) ==&apos;function&apos;) &#123;</span><br><span class="line">    this.msgCallbackMap[msgBody.callbackID] = callback;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    console.log(&apos;error!callback is not function&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   _callIOSNative</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function _callIOSNative(msg)&#123;</span><br><span class="line">   var isWkWebView =  window.webkit.messageHandlers.CSJSWebViewBridgeCore ? true : false;</span><br><span class="line">  if(!isWkWebView)&#123;</span><br><span class="line">  CSJSWebViewBridgeCore.callApp(msg);</span><br><span class="line">  &#125;else &#123;</span><br><span class="line">  window.webkit.messageHandlers.CSJSWebViewBridgeCore.postMessage(msg);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>JS通过以上两个方法调用后，native端通过相应实现来接收通信：</p>
<p>1.UIWebView, CSUIWebViewJavascriptBridge:</p>
<p><strong>CSUIWebViewJavascriptBridge.m</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)callApp:(id)message</span><br><span class="line">&#123;</span><br><span class="line">    [super callAppNative:message];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JSContext注入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)injectJSContext</span><br><span class="line">&#123;</span><br><span class="line">    JSContext *jsContext = [self.webView valueForKeyPath:CSJSContext];</span><br><span class="line">    jsContext [CSJSNativeObject] = self;</span><br><span class="line">    self.jsContext = jsContext;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">protocol方法定义：与JS约定的底层通信方法callApp定义</span><br></pre></td></tr></table></figure>
<p>@protocol CSJavaScriptProtocolExport <jsexport></jsexport></p>
<ul>
<li>(void)callApp:(id)message;</li>
</ul>
<p>@end<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>(instancetype)init<br>{<br>  self = [super init];<br>  if (self) {</p>
<pre><code>class_addProtocol([self class], @protocol(CSJavaScriptProtocolExport));
</code></pre><p>  }<br>  return self;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这样在UIViewView内核下CSUIWebViewJavascriptBridge就收到了JS的callApp的调用，并且通过message收到了调用数据参数，根据数据参数，native进行相关业务的调用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.WKWebView, CSWKWebViewJavascriptBridge:</span><br><span class="line"></span><br><span class="line">**CSWKWebViewJavascriptBridge.m**</span><br><span class="line"></span><br><span class="line">在WKWebView内核下CSWKWebViewJavascriptBridge通过didReceiveScriptMessage方法接收通信</span><br></pre></td></tr></table></figure>
</li>
<li><p>(void)userContentController:(WKUserContentController <em>)userContentController didReceiveScriptMessage:(WKScriptMessage </em>)message<br>{<br>  [super callAppNative:message.body];<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">与JS约定的对象注入</span><br></pre></td></tr></table></figure>
<p>WKUserContentController *userContentController = [[WKUserContentController alloc] init];<br>[userContentController addScriptMessageHandler:self name:CSJSNativeObject];</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">为了实现web,native两端统一的模块化开发，目前约定JS调用native根据业务模块的划分来进行调用，在JS调用时：</span><br><span class="line"></span><br><span class="line">比如在JS端common业务，包括获取native的位置信息，用户信息，调用原生分享等等，这些统一定义为action,getLocationInfoAction,getUserInfoAction,shareAction等，均在模块commonHandler中定义，</span><br><span class="line"></span><br><span class="line">另外调用原生showTipAction提示框，refreshAction刷新等这些均在commonUIHandler中定义，</span><br><span class="line">比如:</span><br><span class="line"></span><br><span class="line">CSJSCommonHandler.js：</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>CSJSCommonHandler.prototype = jsBridge;</p>
<p>CSJSCommonHandler.prototype.getUserInfo = function(callback){<br>    var msg = {};<br>    msg.handler = ‘common’;<br>    msg.action = ‘getUserinfo’;<br>    jsCommonHandler.webCallNative(msg, callback);<br>}</p>
<p>CSJSCommonHandler.prototype.getDeviceInfo = function(callback){<br>    var msg = {};<br>    msg.handler = ‘common’;<br>    msg.action = ‘getDeviceInfo’;<br>    jsCommonHandler.webCallNative(msg, callback);<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如上getDeviceInfo调用：</span><br></pre></td></tr></table></figure>
<p>jsCommonHandler.getDeviceInfo((data) =&gt; {</p>
<p>   });<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">native端根据webView类型不同，根据CSUIWebViewJavascriptBridge或者CSWKWebViewJavascriptBridge收到JS消息后，由基类CSWebViewJavascriptBridge统一处理：</span><br><span class="line"></span><br><span class="line">callAppNative:</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>(void)callAppNative:(id)message<br>{<br>  if ([message isKindOfClass:[NSDictionary class]])<br>  {</p>
<pre><code>CSJSMessage *messageBody = [CSJSMessage messageWithDictionary:message];
if(![self checkJSMessageParameterValid:messageBody])
{
    return;
}
[[CSJSBridgeActionHandlerManager shareManager] callHandler:messageBody.handler message:messageBody JSCallBackBlock:^(CSJSMessage *message) {

    self.nativeCallWebFunction = messageBody.nativeCallWebFunction;

    //有回调，处理回调:ios回调js，js中对应的对象及方法，如::bridge.callbackWeb,动态获取，非写死
    if (message.callbackID.length) {
        self.jsCallbackFunction = message.callbackFunction;
        NSString* script = [NSString stringWithFormat:@&quot;%@(&apos;%@&apos;);&quot;, self.jsCallbackFunction,[message toJavascriptMessage]];
        CSLog(@&quot;callJSWithScript:%@&quot;,script);
        [self callJSWithAction:message.action script:script];
    }
}];
</code></pre><p>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">native处理JS需要相应的业务处理，处理方案如下：</span><br><span class="line"></span><br><span class="line">根据message中参数action,handler来选择对应模块handler中对应action来进行调用，对于如何调用handler，action来派分业务，笔者经过了几种不同的设计方案：</span><br><span class="line"></span><br><span class="line">1. 直接对bridge类增加xxAction category来处理action；</span><br><span class="line"></span><br><span class="line">2. 提前在load方法中注册对应action-actionName的映射，之后调用时通过actionName取映射action来进行调用；</span><br><span class="line"></span><br><span class="line">3. 将action首先通过manager分发到对应handler模块中，再由handler模块来分发到对应的action中，handlers通过plist映射注册到manager中，actions也通过plist文件映射注册到handler中；</span><br><span class="line"> </span><br><span class="line"> 方案一通过category来划分业务，略为粗旷，不够细；</span><br><span class="line"> </span><br><span class="line"> 方案二通load注册，action越来越多的情况下，对程序启动不太好（load方法在pre-main阶段执行）；</span><br><span class="line"> </span><br><span class="line"> 方案三是目前使用的方案，即提供了模块化的方案，同时也能进行懒注册，plist方式的映射，岂不赏心悦目？</span><br><span class="line"> </span><br><span class="line"> 对于方案三，技术实现如下：</span><br><span class="line"> </span><br><span class="line"> 1. handler由CSJSBridgeActionHandlerManager分发：</span><br><span class="line"> </span><br><span class="line"> **//CSJSBridgeActionHandlerManager.m**</span><br><span class="line"> </span><br><span class="line"> handler-handlername映射</span><br></pre></td></tr></table></figure>
<p>/**<br>从CSJSSupportHandlers.plist加载所有JS调native所有handler的，并且通过handlerName,handler映射到内存中，通过动态调用handle模块</p>
<p>@return &lt;#return value description#&gt;<br>*/</p>
<ul>
<li><p>(NSMutableDictionary &lt;NSString <em>,id<csjshandlerprotocol>&gt;</csjshandlerprotocol></em>)supportJSHandlersMap<br>{<br>if (!_supportJSHandlersMap) {</p>
<pre><code>_supportJSHandlersMap = [NSMutableDictionary dictionaryWithCapacity:1];
NSString *mapPath = [[NSBundle mainBundle] pathForResource:@&quot;CSJSSupportHandlers&quot; ofType:@&quot;plist&quot;];
NSParameterAssert(mapPath);
NSDictionary *map = [NSDictionary dictionaryWithContentsOfFile:mapPath];
[map enumerateKeysAndObjectsUsingBlock:^(NSString* _Nonnull handlerName, NSString * _Nonnull handlerClassString, BOOL * _Nonnull stop) {
    Class handlerClass = NSClassFromString(handlerClassString);
    id handler = [[handlerClass alloc] init];
    if(!handler)
    {
        CSLog(@&quot;handlerClass not exist:%@&quot;,handlerClassString);
    }
    else{
        if ([handler conformsToProtocol:@protocol(CSJSHandlerProtocol)]) {
            //registerHandler:
            [_supportJSHandlersMap setObject:handler forKey:handlerName];
            CSJSHandler *jsHandler = (CSJSHandler *)handler;
            jsHandler.handlerName = handlerName;
        }else{
            CSLog(@&quot;handler:%@ not conform to protocol:%@&quot;,handler, NSStringFromProtocol(@protocol(CSJSHandlerProtocol)));
        }
    }
}];
CSLog(@&quot;supportJsHandlerMap:%@&quot;,_supportJSHandlersMap);
</code></pre><p>}<br>return _supportJSHandlersMap;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">handler调用</span><br></pre></td></tr></table></figure>
</li>
<li><p>(void)callHandler:(NSString *)handlerName</p>
<pre><code>message:(CSJSMessage *)message
</code></pre><p>JSCallBackBlock:(CSJSCallBackBlock)jsCallBackBlock<br>{<br>id <csjshandlerprotocol>handler = self.supportJSHandlersMap[handlerName];<br>if (!handler) {</csjshandlerprotocol></p>
<pre><code>CSLog(@&quot;error,handler:%@ not register&quot;,handlerName);
</code></pre><p>}<br>else<br>{</p>
<pre><code>if([handler respondsToSelector:@selector(callAppAction:message:jsCallBackBlock:)])
{
    [handler callAppAction:message.action message:message jsCallBackBlock:jsCallBackBlock];
}
else
{
    NSLog(@&quot;error,handler not respondsToSelector &apos;callAppActionWithMessage: &apos;&quot;);
}
</code></pre><p>}<br>}</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. action由CSHandler分发：</span><br><span class="line"></span><br><span class="line">**CSJSHandler.m**</span><br><span class="line"></span><br><span class="line">action-actionName映射</span><br></pre></td></tr></table></figure>
<p>/**<br>从CSJSXXSupportAction.plist加载JS调native某个handler下的所有action的，并且通过actionName,action映射到内存中，通过动态调用action业务</p>
<p>@return &lt;#return value description#&gt;<br>*/</p>
<ul>
<li><p>(NSMutableDictionary &lt;NSString <em>,id<csjsactionprotocol>&gt;</csjsactionprotocol></em>)supportJSActionsMap<br>{<br>if (!_supportJSActionsMap) {</p>
<pre><code>_supportJSActionsMap = [NSMutableDictionary dictionaryWithCapacity:1];

NSString *handlerName = [self.handlerName capitalizedStringWithLocale:[NSLocale currentLocale]];
NSString *plistName = [[@&quot;CSJS&quot; stringByAppendingString:[NSString stringWithFormat:@&quot;%@&quot;,handlerName]] stringByAppendingString:@&quot;SupportActions&quot;];
NSString *mapPath = [[NSBundle mainBundle] pathForResource:plistName ofType:@&quot;plist&quot;];
NSParameterAssert(mapPath);
NSDictionary *map = [NSDictionary dictionaryWithContentsOfFile:mapPath];
[map enumerateKeysAndObjectsUsingBlock:^(NSString* _Nonnull actionName, NSString * _Nonnull actionClassString, BOOL * _Nonnull stop) {
    Class actionClass = NSClassFromString(actionClassString);
    id action = [[actionClass alloc] init];
    if(!action)
    {
        CSLog(@&quot;actionClass not exist:%@&quot;,actionClassString);
    }
    else{
        if ([action conformsToProtocol:@protocol(CSJSActionProtocol)]) {
            //registerAction:
            [_supportJSActionsMap setObject:action forKey:actionName];
            CSJSAction *jsAction = (CSJSAction *)action;
            jsAction.actionName = actionName;
        }else{
            CSLog(@&quot;action:%@ not conform to protocol:%@&quot;,action, NSStringFromProtocol(@protocol(CSJSHandlerProtocol)));
        }
    }
}];
NSLog(@&quot;supportJsActiomMap:%@&quot;,_supportJSActionsMap);
</code></pre><p>}<br>return _supportJSActionsMap;<br>}</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">3. action真正调用：</span><br></pre></td></tr></table></figure>
<p>/**<br>JS主动调native，</p>
<p>@param actionName action,如share,getUserInfo,getDeviceInfo<br>@param message JS传递到native的数据<br>@param jsCallBackBlock native回调到JS的Block<br>*/</p>
</li>
<li><p>(void)callAppAction:(NSString <em>)actionName message:(CSJSMessage </em>)message jsCallBackBlock:(CSJSCallBackBlock)jsCallBackBlock<br>{<br>  id <csjsactionprotocol>action = self.supportJSActionsMap[actionName];<br>  if (!action) {</csjsactionprotocol></p>
<pre><code>CSLog(@&quot;error,action:%@ not register&quot;,actionName);
</code></pre><p>  }<br>  else<br>  {</p>
<pre><code>if([action respondsToSelector:@selector(callAppActionWithMessage:jsCallBackBlock:)])
{
    [action callAppActionWithMessage:message jsCallBackBlock:jsCallBackBlock];
}
else
{
    CSLog(@&quot;error,action not respondsToSelector &apos;callAppActionWithMessage:jsCallBackBlock:&apos;&quot;);
}
</code></pre><p>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">比如 CSGetDeviceInfoAction：</span><br><span class="line"></span><br><span class="line">在对应action中处理业务逻辑，处理完之后jsCallBackBlock进行回调，回到CSWebViewJavascriptBridge中进行callback</span><br><span class="line"></span><br><span class="line">**CSGetDeviceInfoAction.m**</span><br></pre></td></tr></table></figure>
</li>
<li><p>(void)callAppActionWithMessage:(CSJSMessage <em>)message jsCallBackBlock:(CSJSCallBackBlock)jsCallBackBlock<br>{<br>  CSJSMessage </em>responceMessage  = message;<br>  //doSth</p>
<p>  jsCallBackBlock ? jsCallBackBlock(responceMessage) : nil;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">callback逻辑如下：</span><br><span class="line"></span><br><span class="line">**CSWebViewJavascriptBridge.m**</span><br></pre></td></tr></table></figure>
<p>[[CSJSBridgeActionHandlerManager shareManager] callHandler:messageBody.handler message:messageBody JSCallBackBlock:^(CSJSMessage *message) {</p>
<pre><code>if (message.callbackID.length) {
    self.jsCallbackFunction = message.callbackFunction;
    NSString* script = [NSString stringWithFormat:@&quot;%@(&apos;%@&apos;);&quot;, self.jsCallbackFunction,[message toJavascriptMessage]];
    CSLog(@&quot;callJSWithScript:%@&quot;,script);
    [self callJSWithAction:message.action script:script];
}
</code></pre><p> }];</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">callJSWithAction即是native调JS方法，在UIWebView，WKWebView中不同实现，</span><br><span class="line">比如UIWebView中</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>[self.jsContext evaluateScript:script];</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该callJSWithAction最终调用JS，调用方法为</span><br></pre></td></tr></table></figure>
<p>jsBridge.callBackWeb(msg);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">此时在JS端收到通信调用,大致思路为从之前的callbackID-callback映射map中根据callbackID取出callback,进行callback调用，如此整个JS-Native-JS的整个调用流程结束。是不是很酸爽？</span><br><span class="line"></span><br><span class="line">**CSJSBridgeCore.js**</span><br></pre></td></tr></table></figure></p>
<p>CSJSBridgeCore.prototype.callbackWeb = function(data){<br>    var message = JSON.parse(data);<br>    var callbackID = message[‘callbackID’];<br>    var callback = this.msgCallbackMap[callbackID];<br>    if(callback){<br>        callback(message);<br>    }<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2. native调用JS:</span><br><span class="line">  这类业务普遍是native端提供相关事件，web端对native的事件进行注册监听。native一旦事件触发，web端对监听的事件进行响应。</span><br><span class="line">  一般监听事件两种：</span><br><span class="line">  </span><br><span class="line">  1. 为webViewController lifeCycle等方法，如viewWillAppear,viewDidAppear,</span><br><span class="line">  2. 为系统application事件，包括ApplicationWillEnterForeground,ApplicationDidEnterBackground,ApplicationWillResignActive,ApplicationDidBecomeActiv等事件。</span><br><span class="line"></span><br><span class="line">  #### 调用流程：</span><br><span class="line">  </span><br><span class="line">  1. native端：对以上两类事件进行监听：</span><br><span class="line">  </span><br><span class="line">  **CSWebBrowViewController.m**</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>(void)addViewControllerlifeCycleEvents<br>{<br>[self.bridge listenEvent:CSJSWebViewWillAppearEvent eventDispatchBlock:^(id data) {</p>
<pre><code>[self.bridge callJS:CSJSWebViewWillAppearEvent message:nil JSCompletionBlock:^(id message) {

}];
</code></pre><p>}];<br>[self.bridge listenEvent:CSJSWebViewDidAppearEvent eventDispatchBlock:^(id data) {</p>
<pre><code>[self.bridge callJS:CSJSWebViewDidAppearEvent message:nil JSCompletionBlock:^(id message) {

}];
</code></pre><p>}];</p>
<hr>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
</li>
<li><p>(void)addApplicationNotificationEvents<br>{<br>[self.bridge listenApplicationEvent:UIApplicationWillEnterForegroundNotification eventDispatchBlock:^(id data) {</p>
<pre><code>[self.bridge callJS:UIApplicationWillEnterForegroundNotification message:nil JSCompletionBlock:^(id message) {

}];
</code></pre><p>}];</p>
</li>
</ul>
<pre><code>[self.bridge listenApplicationEvent:UIApplicationDidBecomeActiveNotification eventDispatchBlock:^(id data) {
    [self.bridge callJS:UIApplicationDidBecomeActiveNotification message:nil JSCompletionBlock:^(id message) {

    }];
}];
</code></pre><p>}</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">事件触发后通知JS端,调用JS约定方法：</span><br></pre></td></tr></table></figure>
<p>  [self.bridge callJS:UIApplicationDidBecomeActiveNotification message:nil JSCompletionBlock:^(id message) {</p>
<pre><code>}];
</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
<p>  jsBridge.nativeCallWeb(msg)</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 在JS端的nativeCallWeb实现:</span><br><span class="line"></span><br><span class="line">从nativeCallMap中取出对应监听事件event的function，进行回调，当然前提是JS端对该</span><br><span class="line">event事件进行了注册监听，其实这个思路和JS端调用native的callback逻辑类似。</span><br></pre></td></tr></table></figure>
<pre><code>  CSJSBridgeCore.prototype.nativeCallWeb = function (action,data){
     var handler = this.nativeCallMap[action];
     if(handler){
       //不知道如何拿到js回调的结果:如以下执行调用(或者异步操作回调到native也未解决)
    //    jsCommonHandler.registerNativeCall(&apos;share&apos;,function (data) {
    //     jsCommonHandler.nativelog(&apos;callFromNative&apos;);
    //     return {};
    //   });
       // var msg = handler(data);
       handler(data);
       var msg = {};
       msg.action = action;
       msg.tip = &apos;jsCompletion&apos;;
       return msg;
    }
} 
</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">JS注册native监听事件方法：</span><br></pre></td></tr></table></figure>
<pre><code>CSJSBridgeCore.prototype.registerNativeCall = function (action,handler) {  
if(handler &amp;&amp; typeof(handler) == &apos;function&apos;){
    this.nativelog(`registerNativeCall action:${action} sucesss`)
    this.nativeCallMap[action] = handler;
}
</code></pre><p>  }</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   至此，native-JS流程结束。</span><br><span class="line"></span><br><span class="line">### 其它</span><br><span class="line">#### 1.两端模块化定义：</span><br><span class="line"></span><br><span class="line">  JS调用native的业务，我们希望通过两端都一致用模块化的思路去定义，一个 JS调用native的事件，我们定义它是在xx模块（handler）中的xxAction。</span><br><span class="line">    </span><br><span class="line">  JS端：</span><br><span class="line">  </span><br><span class="line">  如commonHandler为一个模块，该模块定义常规性的调用native的操作，比如调起分享action，获取用户信息数据action，获取设备信息action等;</span><br><span class="line">  coreHandler为一个最底层模块，目前只有logAction;</span><br></pre></td></tr></table></figure>
<p>  CSJSCommonHandler.prototype.getDeviceInfo = function(callback){<br>        var msg = {};<br>        msg.handler = ‘common’;<br>        msg.action = ‘getDeviceInfo’;<br>        jsCommonHandler.webCallNative(msg, callback);<br>    }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  而对应在native端：</span><br><span class="line">  </span><br><span class="line">  由CSJSCommonHandler模块来处理该模块action，具体action由handler分发到对应action来处理业务：</span><br><span class="line">  CSJSShareAction，CSGetDeviceInfoAction</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">#### 2.native调用JS时方法的动态化：</span><br><span class="line">  该方案中在native中对JS的调用有两处，一处是JS主动调用native，native处理业务之后回调JS，此时会调用JS的callback方法，二处是native主动向JS发送native事件callweb。native端这样直接调用JS，不免会有硬编码的诟病，而且一旦JS端方法发生变化，native端是完全无感知的，所以，方案里是使用了另外一种方式。native调JS的方法是通过JS传递给native端的，native端保存之后再进行相关调用。</span><br><span class="line"> </span><br><span class="line"> 如下的nativeCallWebFunction，callbackFunction便是从JS传递数据解析过来的：</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>(void)callAppNative:(id)message<br>{<br>if ([message isKindOfClass:[NSDictionary class]])<br>{</p>
<pre><code>[[CSJSBridgeActionHandlerManager shareManager] callHandler:messageBody.handler message:messageBody JSCallBackBlock:^(CSJSMessage *message) {

    self.nativeCallWebFunction = messageBody.nativeCallWebFunction;

    //有回调，处理回调:ios回调js，js中对应的对象及方法，如::bridge.callbackWeb,动态获取，非写死
    if (message.callbackID.length) {
        self.jsCallbackFunction = message.callbackFunction;
        NSString* script = [NSString stringWithFormat:@&quot;%@(&apos;%@&apos;);&quot;, self.jsCallbackFunction,[message toJavascriptMessage]];
    }
}];
</code></pre><p>}<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">#### 3.log调试：</span><br><span class="line">  之前在项目中老的JS-native通信中经常遇到一些问题很难调试，native端无法知道JS调用的结果异常与否，所以在corehandler里加了logAction来帮助将JS端的log直接输出到native端。</span><br><span class="line">   </span><br><span class="line">   JS端：</span><br></pre></td></tr></table></figure>
<p>CSJSBridgeCore.prototype.nativelog = function (data) {<br>var msgBody = {};<br>msgBody.handler = ‘core’;<br>msgBody.action = ‘nativelog’;<br>msgBody.data = data;<br>this.webCallNative(msgBody);<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">native端：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**CSJSLogAction.m**</span><br></pre></td></tr></table></figure>
<ul>
<li>(void)callAppActionWithMessage:(CSJSMessage <em>)message jsCallBackBlock:(CSJSCallBackBlock)jsCallBackBlock<br>{<br>CSJSMessage </em>responceMessage  = message;<br>NSDictionary <em>dic = [responceMessage toDictionary];<br>NSData </em>jsonData = [NSJSONSerialization dataWithJSONObject:dic options:NSJSONWritingPrettyPrinted error:nil];<br>NSString *jsonString = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];<br>CSLog([[@”&lt;&lt;\n fromJslog: “ stringByAppendingString:jsonString] stringByAppendingString:@”\n&gt;&gt;”]);<br>jsCallBackBlock ? jsCallBackBlock(responceMessage) : nil;<br>}<br><code>`</code></li>
</ul>
</li>
</ul>
<h4 id="4-关于JS端依赖模块的编写："><a href="#4-关于JS端依赖模块的编写：" class="headerlink" title="4.关于JS端依赖模块的编写："></a>4.关于JS端依赖模块的编写：</h4><p>   本方案中JS端核心代码为CSJSBridgeCore.js文件，JS端新模块业务直接调用CSJSBridgeCore的方法，参照模块为CSJSCommonHandler.js。<br>   CSJSBridgeCore.js的使用有两种方式：</p>
<ol>
<li>可由web页面script标签引入；</li>
<li>可提前在native端执行；</li>
</ol>
<p>CSWebViewJavascriptBridge使用的是第二种。</p>
<p>目前CSJSBridgeCore.js的编程思想，整个文件为一个执行闭包，核心对象为CSJSBridgeCore，挂载在window上的一个全局对象。对于现在web的SPA应用开发，这并不是标准的模块化编程方式。这一块可在之后使用es6的模块化方式进行书写，支持npm。</p>
<h4 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h4><p>待更新 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/dormitory219/2018/07/29/一个优雅的hybrid方案：native,JS端两端实现/" data-id="cjls31k330005gntx1dk93wwy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/07/29/Web前后端项目部署阿里云服务器/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          前后端项目部署阿里云服务器
        
      </div>
    </a>
  
  
    <a href="/2018/07/29/日常开发小集/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">日常开发小集</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/07/29/Vue项目实战/">Vue项目实战:集vue webpack node.js es6 styles 线上部署等技术栈实战</a>
          </li>
        
          <li>
            <a href="/2018/07/29/CSReduxKit - 单向数据流方案/">CSReduxKit:单向数据流方案</a>
          </li>
        
          <li>
            <a href="/2018/07/29/CSPopKit - 一个弹窗实现方案/">CSPopKit:一个弹窗实现方案</a>
          </li>
        
          <li>
            <a href="/2018/07/29/一个对臃肿业务的AppDelegate模块的瘦身方案/">一个对臃肿业务的AppDelegate模块的瘦身方案</a>
          </li>
        
          <li>
            <a href="/2018/07/29/Web前后端项目部署阿里云服务器/">前后端项目部署阿里云服务器</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Joy<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>